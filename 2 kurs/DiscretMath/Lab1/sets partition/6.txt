Перейдем теперь к рассмотрению способа генерации всех разбиений исходного множества.

Прежде всего следует договориться о том, как обозначать текущее разбиение. Так как в
каждом из разбиений участвуют все элементы исходного множества, будем в массиве индексов
p записывать, в какой блок попадает каждый из элементов в текущем разбиении. Параметр i
в рекурсивной процедуре part означает, что на текущем шаге мы именно i-й элемент будем
размещать в каждом из допустимых для него блоков, а j как раз и определяет максимальный
номер допустимого блока. После того как i-й элемент помещен в один из блоков, рекурсивно
решается такая же задача уже для следующего элемента (в данном случае фактически работает
универсальная схема перебора с возвратом [8]).


procedure partition(n: integer; var p: list);
    procedure part(i, j: integer);
        var l: integer;
        begin
            if i > n then print(n, p)
            else
                for l := 1 to j do
                begin
                    p[i] := l;
                    if l = j then part(i + 1, j + 1)
                    else part(i + 1, j)
                end
        end; {part}

begin {partition}
   part(1,1)
end;

procedure print(n: integer; var p: list);
    var i, j, imax: integer;
begin
    {определяем количество блоков в разбиении}
    imax := 1;
    for i := 2 to n do
        if p[i] > imax then imax := p[i];
    for i := 1 to imax do
    {цикл по блокам}
    begin
        for j := 1 to n do
            if p[j] = i then write(a[j]:4);
        write(' |') 
        {блок напечатан}
    end;
    writeln {разбиение напечатано}
end;
