Под разбиением n-элементного множества X на k блоков будем понимать произвольное семейство P = {B1,...,Bk},
такое что B1∪...∪Bk = X, Bi ∩ Bj = Ø для 1 ≤ i < j ≤ k и Bi ≠ Ø для 1 ≤ i ≤ k. Подмножества B1,...,Bk будем
называть блоками семейства P.

Идею этого алгоритма легче всего объяснить, сформулировав его в рекуррентной форме. Отметим сначала, что
каждое разбиение P множества {1,...,n} однозначно определяет разбиение Pn-1 множества {1,...,n-1}, возникшее
из P после удаления элемента n из соответствующего блока (и удаления образовавшегося пустого блока, если
элемент n образовывал одноэлементный блок). Напротив, если дано разбиение а = {B1,...,Bk} множества {1,...,n-1},
легко найти все разбиения P множества {1,...,n}, такие что Pn-1 = a.

Это подсказывает следующий простой рекуррентный метод генерирования всех разбиений: если нам дан список Ln-1
всех разбиений множества {1,...,n-1}, то список Ln всех разбиений множества {1,...,n} будем создавать, заменяя
каждое разбиение a в списке Ln-1 на соответствующую ему последовательность. Отметим, что при этом мы можем
гарантировать, что разбиения, идущие друг за другом, будут мало отличаться друг от друга, точнее говоря, мы можем
принять, что каждое следующее разбиение в списке образуется из предыдущего посредством удаления некоторого
элемента из некоторого блока (это может повлечь за собой удаление одноэлементного блока) и добавления его в
другой блок, либо создания из него одноэлементного блока.

Нерекуррентная реализация алгоритма может быть дана следующим образом. Разбиение множества {1,...,n} может быть
представлено с помощью последовательности блоков, упорядоченной по возрастанию самого маленького элемента в блоке.
Этот наименьший элемент блока мы будем называть номером блока. Отметим, что номера соседних блоков, вообще говоря,
не являются соседними натуральными числами. В этом алгоритме мы будем использовать переменные PREVIOUS[i], NEXT[i],
содержащие соответственно номер предыдущего и номер следующего блока для блока с номером i (NEXT[i] = 0, если блок
с номером i является последним блоком разбиения). Для каждого элемента i номер блока, содержащего элемент i, будет
храниться в переменной BLOCK[i], направление, в котором движется элемент i, будет закодировано в булевской переменной
FORWARD[i] (FORWARD[i] = true, если i движется вперед).

Этот алгоритм строит сначала разбиение {{1,...,n}} — это первое разбиение в списке Ln, созданном при помощи
описанного рекуррентного метода. Задача основного цикла — перемещение активного элемента j в соседний блок предыдущий
или последующий (в последнем случае может возникнуть необходимость создания нового блока вида {j}), а затем
определение активного элемента во вновь образованном разбиении. Из описанного рекуррентного построения следует, что
данный элемент перемещается только тогда, когда все элементы, большие его, достигают своего крайнего левого или правого
положения; точнее, активный элемент j* является таким наименьшим элементом, что для каждого большего элемента j
выполняется одно из двух следующих условий:

(1) FORWARD[j] and (BLOCK[j] = j)
т. е. элемент движется вперед и достигает своего крайнего правого положения (очевидно, j не может быть элементом блока
с наименьшим элементом, большим j).

(2) not FORWARD[j] and (BLOCK[j] = 1)
т. е. элемент j движется назад и достигает своего крайнего левого положения (в первом блоке).

Если каждый из элементов j > 1 отвечает условию (1) или (2), то легко убедиться, что уже порождены все разбиения.

При переносе активного элемента сначала отыскивается номер блока, содержащего активный элемент; пусть это будет k. Если
этот элемент движется вперед, достаточно перенести его в блок с номером NEXT[k], а в двух остальных случаях переменную
NEXT[k] нужно сначала модифицировать. Первый случай имеет место, когда NEXT[k] = 0, т. е. когда k есть номер последнего
блока разбиения. Тогда j образует одноэлементный блок; при этом достаточно принять NEXT[k] = j и соответственно изменить
значения переменных NEXT[j] и PREVIOUS[j]. Второй случай имеет место, когда NEXT[k] > j, он рассматривается аналогично.
Условие NEXT[k] > j означает, что все блоки справа от блока с номером k содержат элементы, большие j (все эти элементы
занимают свои крайние правые позиции, в противном случае j не был бы активным элементом). Из рекуррентности алгоритма
легко вытекает, что в этом случае нужно создать одноэлементный блок, содержащий j. Единственная разница с первым случаем
состоит в том, что в данном случае вновь созданный блок не является последним блоком разбиения. В ситуации, когда элемент
j движется назад, достаточно поместить его в предыдущий блок и выполнить соответствующее изменение значений переменных
NEXT и PREVIOUS, если j создавал одноэлементный блок — это имеет место в точности тогда, когда BLOCK[j] = k = j, так как
каждый элемент m > j блока с номером j был бы выбран активным элементом.

Cреднее число шагов, необходимых для построения каждого следующего разбиения, ограничено постоянной, не зависящей от n.

Пример последовательности разбиений множества {1,2,3,4}, порожденной алгоритмом.

( 1 2 3 4 )
( 1 2 3 ) ( 4 )
( 1 2 ) ( 3 ) ( 4 )
( 1 2 ) ( 3 4 )
( 1 2 4 ) ( 3 )
( 1 4 ) ( 2 ) ( 3 )
( 1 ) ( 2 4 ) ( 3 )
( 1 ) ( 2 ) ( 3 4 )
( 1 ) ( 2 ) ( 3 ) ( 4 )
( 1 ) ( 2 3 ) ( 4 )
( 1 ) ( 2 3 4 )
( 1 4 ) ( 2 3 )
( 1 3 4 ) ( 2 )
( 1 3 ) ( 2 4 )
( 1 3 ) ( 2 ) ( 4 ) 
